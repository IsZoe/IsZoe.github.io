{"meta":{"title":"Cloud","subtitle":"From end to beginning","description":"","author":"Zoe","url":"http://iszoe.github.io"},"pages":[],"posts":[{"title":"呕心沥血对 JavaScript 中 this 的理解","slug":"this","date":"2018-01-31T06:01:36.000Z","updated":"2018-02-26T08:14:00.701Z","comments":true,"path":"2018/01/31/this/","link":"","permalink":"http://iszoe.github.io/2018/01/31/this/","excerpt":"","text":"this到底指向哪里在JavaScript 中，函数中this到指向，经常会引起自己的困惑，所以写一篇文章来整理下自己对这个疑点的理解。 函数的执行所有的 JavaScript 函数都有一个内部属性[[Call]]，用来运行该函数。1F.[[Call]](thisArg, argumentsList) 上面代码中，F是一个函数对象，[[Call]]是它的内部方法，F.[call]表示运行该函数，thisArg表示[[Call]]运行时this的值，argumentsList则是调用时传入函数的参数。 thisArg和this是什么关系？ECMA规范里的描述是这样的： If the function code is strict code, set the ThisBinding to thisArg.在格模式下，thisArg和this是一一对应的。&nbsp;Else if thisArg is null or undefined, set the ThisBinding to the global object.如果thisArg为null或者undefined则this指向全局对象。&nbsp;Else if Type(thisArg) is not Object, set the ThisBinding to ToObject(thisArg).如果thisArg为非对象类型，则会强制转型成对象类型。&nbsp;Else set the ThisBinding to thisArg.剩下的情况thisArg和this为一一对应的关系。 概括一下就是3条：1.thisArg和this是一一对应。2.非严格模式下thisArg为null或者undefined则this指向全局对象。3.如果thisArg为非对象类型，则会强制转型成对象类型。 记住这三条，JavaScript 和其他语言不同的是，函数中this的指向不是在函数声明时指定的，而是调用时指定。那this到底是指向哪里呢？ In JavaScript, as in most object-oriented programming languages, this is a special keyword that is used within methods to refer to the object on which a method is being invoked.一般而言JavaScript中，this 指向函数执行的当前对象 在JavaScript 中函数调用大概有这4中情况: 1.调用对象方法 2.普通函数调用 3.间接调用 4.构造函数调用 我们分别来看一下这四种情况 1.调用对象方法调用对象的方法类似 obj.fn() 的调用形式。 举个栗子 12345678910111213var a = &#123; name: 'bob', showName: function()&#123; console.log(this.name) &#125;&#125;var b = &#123; name: 'lily', showName: a.showName&#125;b.showName() //lily b.showName()函数引用了函数a.showName,this是在函数执行时指定，showName()执行时，this指向了此时showName函数运行时的所在宿主对象b。 回顾一下 JavaScript 函数内部属性[[Call]]1F.[[Call]](thisArg, argumentsList) 一般而言JavaScript中，this 指向函数执行的当前对象，函数执行时 thisArg 传入的是此时函数的宿主对象。 再来看看下面的图：函数b.showName()和a.showName() 指向了同一个函数，当使用a.showName()方法调用时，this指向宿主对象a,使用a.showName()调用时,则this指向宿主对象b。 2.普通函数调用直接调用声明的函数 fn()。 一个栗子1234567891011var name = 'jack'var a = &#123; name: 'bob', showName: function()&#123; console.log(this.name) &#125;&#125;var b = a.showName;b() //jack b函数是引用的函数a.showName，在b()执行的时候没有明确的宿主对象。这个时候拿出我们刚才看的ECMA规则，1F.[[Call]](thisArg, argumentsList) 没有明确宿主对象的时候 thisArg 传入的相当于 null 或者 undefined，非严格模式下 thisArg 为 null 或者 undefined 则 this 指向全局对象。在浏览器中 this 指向全局对象 window 。 再举个栗子 –立即执行函数12345678910111213var name = 'jack'var a = &#123; name: 'bob', showName: function()&#123; (function()&#123; console.log(this.name) &#125;()) &#125;&#125;var b = a.showName;b() //jack b()函数中声明了一个立即执行的匿名函数，继续回顾 JavaScript 函数内部属性[[Call]]1F.[[Call]](thisArg, argumentsList) b()函数执行时没有明确的宿主对象，thisArg 传入的是 null 或者 undefined，此时 this 在浏览器中指向 window 。 3.间接调用间接调用是指使用 apply 和 call ，bind 等方法改变函数执行当前对象。方法的第一个参数改变函数中 this 的指向。 举个栗子1234567891011var age = 18;var a = &#123; name:'lili', age:16&#125;var b = function()&#123; console.log(this.age)&#125;b() // 18b.call(a) //16 F.call(thisObj,[arg1……]) 方法的 thisObj 和 arglist 会作为 F 内部属性 [[Call]] 的参数传入进行函数的执行操作。上面这个栗子 b 函数使用 call(a) 方法调用函数，会将第一个参数对象 a 作为 b 函数内部属性[[Call]]的第一个参数 thisArg 来执行函数。此时b 函数内部 this 指向 a，this.age 为 a.age 打印出16。 apply 和 call 都会立即调用函数，两者的区别就是 arglist 传参格式不同。call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。123456call([thisObj[,arg1[, arg2[, [,.argN]]]]])apply([thisObj[,argArray]])-------------------------------------------fn.call(thisObj,args1,args2);//或者fn.apply(thisObj,[args1,args2]); 而 bind 是返回对应函数，不会立即调用。bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 1fn.bind(thisObj,args1,args2); //bind不会立即调用对应函数，会返回一个绑定函数 有一个地方值得注意 1234567891011121314function a()&#123; console.log(this)&#125;function b()&#123;&#125;var c = &#123;&#125;;a.call(); //windowa.call(null); //windowa.call(undefined); //windowa.call(1); //Numbera.call(''); //Stringa.call(true); //Booleana.call(b); //function b()&#123;&#125;a.call(c); //Object 在浏览器环境下，传入空，null，undefined 都会指向 window。如果传入 String，Boolean，Number 等基础类型，会返回一个包装过的对象。 4.构造函数调用构造函数调用指使用 new 关键词，调用构造器，创建一个新对象。 举个栗子1234567function Worker()&#123; this.name = 'lily'; this.age = '16'; console.log(this);&#125;Worker(); // windownew Worker(); // Worker &#123;name: \"lily\", age: \"16\"&#125; 函数调用 new 操作符时，会创建一个新对象，并用 this 指向它。 其他的一些疑点一般而言JavaScript中，this 指向函数执行的当前对象，函数的调用一般可以概括为上面4中情况。但是还有一些特殊的情况，影响 this 的指向。 setTimeout , setInterval 函数执行时 this 的对象时全局对象举个栗子 1234567891011var a = &#123; name: 'lucy', showName: function()&#123; console.log(this); &#125;, myName: function()&#123; //此时的 this 指向对象a setTimeout(this.showName,1000) //setTimeout 延迟执行 a.showName 函数中的this 指向window &#125;&#125; a.myName()// window setTimeout 中的延迟执行的代码中的 this 永远都指向 window。 我们可以使用 bind 方法，改变函数内 this 的指向1234567891011var a = &#123; name: 'lucy', showName: function()&#123; console.log(this); &#125;, myName: function()&#123; //此时的 this 指向对象a setTimeout(this.showName.bind(this),1000) //setTimeout 延迟执行 a.showName 函数中的this 指向window &#125;&#125; a.myName()// &#123;name: \"lucy\", showName: ƒ, myName: ƒ&#125; 超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined—-《JavaScript高级程序设计》 再看一个栗子，使用setTimeout(字符串代码, 延迟) 123456789101112131415161718var name = 'lili';function b ()&#123; var name = 'jack'; setTimeout(function()&#123; console.log(name); //函数内声明的变量 name console.log(this.name); //this 指向window window.name lili &#125;,1000)&#125;function c ()&#123; var name = 'lucy'; setTimeout('console.log(name)',1000) setTimeout('console.log(this.name)',1000)&#125;b() // jack lilic() // lili lili 对比一下 123456789101112var name = 'lili';var a = &#123; name: 'lucy', showName: function()&#123; console.log(name); console.log(this.name); &#125;, myName: function()&#123; setTimeout(\"this.showName()\",1000) //在window全局作用域下创建 函数this.showName()，window下无showName方法。 &#125;&#125;a.myName() // Uncaught TypeError: this.showName is not a function 有个共同的现象如果setTimeout(字符串代码, 延迟)使用这种方式执行的函数，默认会在 window 全局作用域下创建一个新的函数。此时this 会指向 window。 小结一下 setTimeout中的延迟执行的代码中的this永远都指向window。 setTimeout(this.showName,1000)，setTimeout 参数中的this，是根据上下文来判断的。 setTimeout(“this.showName()”,1000) 执行代码如果是字符串形式的代码，默认在window全局作用域下创建一个新的函数。 eval 方法解析出的this12345678var name = 'jack'var a = &#123; name: 'bob', showName: function()&#123; eval('console.log(this.name)'); //和直接执行console.log(this.name) 相同 &#125;&#125;a.showName() // bob eval 相当于是在当前位置填入代码。 lamda表达式(箭头函数)中 this 的指向lamda 表达式俗称肩头函数。箭头函数 this 的定义：箭头函数中的 this 是在定义函数的时候绑定，而不是在执行函数的时候绑定。这个和普通函数的 this 绑定刚好相反。 举个栗子 123456789101112var a = &#123; name: 'lucy', showName: function()&#123; console.log(this.name); &#125;, myName: function()&#123; setTimeout(() =&gt; &#123; this.showName(); &#125;,1000) &#125;&#125;a.myName()// lucy setTimeout 执行的匿名函数为箭头函数，定义时就绑定了上下文中的 this ，即使在 setTimeout 延迟在全局作用域中执行，因为已经绑定了 this ，所以仍旧指向 a.name 。 use strict 模式对this的影响严格模式下的函数调用，回忆一下文章刚开始介绍的ECMA规则第一条：thisArg和this是一一对应。在非严格模式下 thisArg 为 null 或者 undefined 则 this 指向全局对象，而在严格模式下 thisArg 和 this 是一一对应，就意味着函数中 thisArg 为 null 或者 undefined 时，this 不会转化指向全局对象，会遵守一一对应原则，传入的什么就是什么。 对比一下下面两个栗子 1234567891011function a()&#123; console.log(this)&#125;(function()&#123; 'use strict'; console.log(this); //undefined a.apply(null) //window a.apply(this) //window a.apply(undefined) //window&#125;)() 1234567891011'use strict';function a()&#123; console.log(this)&#125;(function()&#123; console.log(this); //undefined a.apply(null) //null a.apply(this) //undefined a.apply(undefined) //undefined&#125;)() use strict 模式在函数内部定义，则只会影响函数内部作用域内的代码执行，不会影响定义在此函数作用域外的函数的代码执行。 总结函数执行是依靠内部属性 [[Call]]，用来运行该函数。属性 [[Call]] 有一个 thisArg 的参数和 this 一一对应。 参考文章Javascript中this关键字详解深入理解函数内部原理（六从Ecma规范深入理解this","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://iszoe.github.io/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://iszoe.github.io/categories/JavaScript/基础/"}],"tags":[]},{"title":"前端自动化测试工具","slug":"mocha","date":"2018-01-30T08:02:14.000Z","updated":"2018-02-06T07:52:11.670Z","comments":true,"path":"2018/01/30/mocha/","link":"","permalink":"http://iszoe.github.io/2018/01/30/mocha/","excerpt":"","text":"在自己编写代码的过程中，因为大部分的业务代码，很少会去写测试用例，当然也很少去关注自动化测试这一块。但是在用到公共组件，模块的时候，编写测试用例，接入自动化测试，让自己写代码的时候有了一剂强心针。 了解一下 TDD（测试驱动开发）或BDD（行为驱动开发）TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD中侧重点偏向开发，有利于更加专注软件设计。BDD对TDD的理念进行了扩展，主要用于测试代码是否符合客户的需求，这里的BDD更加侧重于代码的功能逻辑。BDD描述的行为就像一个个的故事(Story) 主要的测试工具 测试框架: mocha Jasmine 等等框架提供了清晰简明的语法来描述测试用例，可以对测试用例精细分组，可以清楚的发现测试抛出的error。这里后续以Mocha为例。 断言库：Should.js、chai、expect.js、Node.js原生assert库 等等断言库提供了很多语义化的方法来对值做各种各样的判断。后续以Should.js为例。 测试管理工具: KarmaKarma 不是一个测试框架，也不是一个断言库，仅仅启动一个 http server，通过你熟知的测试框架生成运行测试的HTML。这个测试工具的一个强大特性就是，它可以监控(Watch)文件的变化，然后自行执行，通过console.log显示测试结果。 Mocha简单的讲讲mocha的语法，举个栗子：1234567describe('Array', function() &#123; describe('#indexOf()', function() &#123; it('should return -1 when the value is not present', function() &#123; assert.equal(-1, [1, 2, 3].indexOf(4)) &#125;) &#125;)&#125;) 上面就是一个简单的测试脚本，测试脚本里面包括一个或多个describe块，每个describe块应该包括一个或多个it块describe块称为“测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（“加法函数的测试”），第二个参数是一个实际执行的函数。 it块称为“测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（“should return -1 when the value is not present”），第二个参数是一个实际执行的函数。 Mocha允许在test目录下面，放置配置文件mocha.opts 测试异步函数12345678describe(\"async\", () =&gt; &#123; it('read book async', function (done) &#123; book.read((err, result) =&gt; &#123; expect(result).to.be.a('string'); done(); &#125;) &#125;)&#125;) 异步函数 有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。 Should.jsShould.js 是一个 BDD 风格的断言库。可以使用.an, .of, .a, .and, .be, .have, .with, .is, .which （什么都不会做）等使得链式语句非常容易阅读。 KarmaKarma 会启动一个web服务器，将js源代码和测试脚本放到指定的浏览器上执行，可用于测试所有主流Web浏览器。Karma 还可以监控文件的变换，立即开始测试。 我们可以全局安装 karma-cli 来简化karma的调用，方便使用karma。1$ npm install -g karma-cli 在项目中使用1$ karma init 会自动生成Karma的配置文件 karma.conf.js ,下面介绍一些常用的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576module.exports = function(config) &#123; config.set(&#123; // base path that will be used to resolve all patterns (eg. files, exclude) // basePath 相对目录，files和exclude里的文件路径都会相对于它 // basePath 就是相对于 karma.config.js 的所在目录（karma目录） basePath: '', // frameworks to use // available frameworks: https://npmjs.org/browse/keyword/karma-adapter // 用到的测试框架，我在这里用的mocha frameworks: ['mocha'], // list of files / patterns to load in the browser //加载至浏览器的文件， //pattern:需要匹配的模式，必须有值 //watched: 默认值 true，如果autoWatch 设为true ，所有watched 属性为true的文件都会被监测变化 //served: 默认值 true，该文件是否由karma webserver 提供 //included：默认值 true，浏览器是否需要通过&lt;script&gt;标签引入该文件。如果你想手动引入，例如通过Require.js ，就将include设为false。 //下面第一个等同于 &#123;pattern: 'js/**.js', watched: true, served: true, included: true&#125; files: [ 'js/**.js', 'test/**.js' ], // list of files to exclude // 浏览器会从 files 里忽略下面的的文件，不加载它们 exclude: [ ], // preprocess matching files before serving them to the browser // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor // 预处理，文件加载至浏览器前可以先进行处理 这里加了测试覆盖率 preprocessors: &#123; 'js/**.js': ['coverage']， //'**/*.coffee': ['coffee'] &#125;, //自定义Launchers customLaunchers: &#123; Chrome_travis_ci: &#123; base: 'Chrome', flags: ['--no-sandbox'] &#125; &#125;, // test results reporter to use // possible values: 'dots', 'progress' // available reporters: https://npmjs.org/browse/keyword/karma-reporter reporters: ['progress','coverage'], //覆盖率报告配置 coverageReporter: &#123; type : 'html', dir : 'coverage/' &#125;, // web server port port: 9876, // enable / disable colors in the output (reporters and logs) colors: true, // level of logging // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG // 控制台打印 log 的等级 logLevel: config.LOG_INFO, // enable / disable watching file and executing tests whenever any file changes // 监听文件 配置在file文件夹中 autoWatch: true, // start these browsers // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher // 测试浏览器，有IE，Chrome，ChromeCanary，FireFox，Opera，Safari，PhantomJS... // # Install the launcher first with NPM: // 选择浏览器的时候要在 npm 里Install 相应的 launcher browsers: ['Chrome'], // Continuous Integration mode // if true, Karma captures browsers, runs the tests and exits // 如果是true，跑完一次所有测试就会退出。 singleRun: false, //默认情况下 karma 会加载所有 karma- 开头的 npm 组件； plugins: ['karma-*'], // Concurrency level // how many browser should be started simultaneous concurrency: Infinity &#125;)&#125; 默认情况下所有资源由http://localhost:[PORT]/base/提供，举个栗子：123files: [ &#123;pattern: 'test/js/name.js', watched: false, included: false, served: true&#125;], 上面的js可以用 http://localhost:[PORT]/base/test/js/name.js 访问(注意URL里的base)你可以设置proxies 来替换路径，举个栗子123proxies: &#123; \"/js/\": \"/base/test/js/\"&#125;, 则可以用 http://localhost:[PORT]/js/name.js 访问。 files 里面也可以直接加载线上文件123files: [ 'https://cdn.bootcss.com/jquery/2.2.4/jquery.js'], 更多用法查看文档 在测试手机浏览器Karma 允许直接打开链接的方式捕获浏览器 http://[hostname]:[port]/ 将hostname 换成你的 IP 地址,在手机中打开(注意在同一网络中)，就可以让测试运行在你的手机浏览器中，可以在控制台看见打印的测试结果。 持续集成CITravis-CI是一个持续集成构建项目，对于Github上的开源项目是免费的。gitlab 也有类似项目 Gitlab CI。 git 开源项目接入 Travis-CI首先需要在 Travis-CI 登录你的 Github 账户 在你的项目里选择需要 CI 构建的项目 在项目的根目录创建 .travis.yml 文件 git push 提交代码，就能自动构建啦 等等… .travis.yml 需要根据你的测试条件来配置123456789101112language: node_jsnode_js: - 'stable' - '4.0.0' - '5.0.0'cache: directories: - node_modulesbefore_install: - npm installscript:after_script: language定义了运行环境的语言,我们创建的是一个JavaScript项目， language 选择 node_js , 而对应的node_js可以定义需要在哪几个Node.js版本做测试，比如这里的定义，代表着会分别在最新稳定版、4.0.0、5.0.0版本的Node.js环境下做测试。 而script则是测试利用的命令,Travis-CI 默认是会执行 npm test 的，我们把自己项目开发所需要的命令都写在package.json的scripts里面，保证 npm test 可用。 而after_script则是在测试完成之后运行的命令 karma 集成到 CI想要在 Readme.md 上显示build:pass的图标点击在弹出框里选择markdown，复制下面文本框里的内容到 Readme.md 上，提交一下就能看到build:pass的图标啦 有一些值得注意的地方: yml格式需要书写正确（确保每个space都必须要正确，travis-ci提供了一个检测工具); 使用脚本的时候不要使用watch模式 对于npm安装，不需要打印安装信息（因为log太多也会构建失败） 更多问题参考文档 代码覆盖率？看看你的测试用例写的怎么样！想每次 Travis-CI 集成自动化测试之后自动生成代码覆盖率报告，在git项目中显示 Coverage Status的图标。和Travis-CI 一样需要登录 coveralls 的网站登录你的 Github 账户，选择需要（ADD REPO）生成测试报告的项目。 使用的 karma 来自动生成代码覆盖率报告需要安装下面两个包 karma-coverage karma-coveralls在karma 的配置文件中 karma.conf.js123456789101112131415preprocessors: &#123; 'quz/*.js': ['coverage'] //add 配置需要测试覆盖率的文件&#125;,// test results reporter to use// possible values: 'dots', 'progress'// available reporters: https://npmjs.org/browse/keyword/karma-reporterreporters: ['progress', 'coverage' ,'coveralls'], //modify 需要生成哪些代码报告coverageReporter: &#123; //覆盖率报告要如何生成，包括覆盖率页面、lcov.info、coverage.json、以及命令行里的提示 type: 'lcov', dir: './coverage/'&#125;,// web server port 这样提交到github上 Travis-CI 跑测试的时候就会自动生成测试报告提交到 coveralls 上 同样的在 coveralls 上，找到 Coverage Status的图标点击右上角EMBED 选择markdown 文本框内容复制到 Readme.md 上，就展示每次执行完成后代码覆盖率的图标啦！参考文档：聊一聊前端自动化测试","categories":[{"name":"测试","slug":"测试","permalink":"http://iszoe.github.io/categories/测试/"}],"tags":[]},{"title":"Linux01","slug":"linux01","date":"2018-01-25T04:00:33.000Z","updated":"2018-02-12T04:45:53.399Z","comments":true,"path":"2018/01/25/linux01/","link":"","permalink":"http://iszoe.github.io/2018/01/25/linux01/","excerpt":"","text":"##111111","categories":[{"name":"Linux","slug":"Linux","permalink":"http://iszoe.github.io/categories/Linux/"}],"tags":[]},{"title":"Hexo 分分钟快速建站","slug":"hexo","date":"2018-01-16T09:57:51.000Z","updated":"2018-02-12T05:25:42.241Z","comments":true,"path":"2018/01/16/hexo/","link":"","permalink":"http://iszoe.github.io/2018/01/16/hexo/","excerpt":"","text":"最近想认真的写一个博客来梳理自己的知识网络，在各路网友的推荐下，找到了 hexo + GitPage，来搭建静态博客，简单快捷，易上手，分分钟帮你建站。 你要做的主要就是三步：1.安装 hexo2.下载一个你喜欢的主题3.执行hexo new XX开始写文章 安装 hexo首先保证你电脑里的 Node.js，Git 已经安装。 使用 npm 完成 Hexo 的安装。1234$ npm install -g hexo-cli$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 具体请参考: 这里 生成的目录结构12345678910├── .deploy #需要部署的文件├── node_modules├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 找到全局配置文件的 _config.yml 修改网站基本信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Site 这里需要根据你自己的网站修改哦title: Cloud # 网站首页的标题subtitle: From end to beginning # 网站副标题 （页面上展示的副标题需要在主题配置文件里设置）description: # 描述author: Zoe # 作者language: zh-CN # 语言 会影响到你主题样式里面的语言哦timezone: Asia/Shanghai # 时区# URLurl: http://iszoe.github.io # 配置你发布路径的urlroot: / # 根目录如果页面不是放在网站跟目录，需要配置rootpermalink: :year/:month/:day/:title/ # 单个文件访问的的路径permalink_defaults:# Directory 目录source_dir: source # 源文件路径文件public_dir: public # 生成的网页文件的路径文件tag_dir: tags # 标签archive_dir: archives # 归档category_dir: categories # 分类code_dir: downloads/codei18n_dir: :lang # 国际化skip_render:# Writing 设置生成博文的默认格式,不用修改new_post_name: :title.md # File name of new postsdefault_layout: post # 默认模板(post page photo draft)titlecase: false # 标题转换成大写external_link: true # 新标签页里打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date# Category &amp; Tag 分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Date / Time format 日期时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页文章数, 设置成 0 禁用分页pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hueman # 主题设置 如果更换主题需要在这里修改主题文件夹的名称# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type:Github # 部署类型, 本文使用Github 基本操作1234567$ hexo new \"文章名\" # 新建一个md$ hexo new 布局 \"文章名\" # 新建一个md$ hexo publish 布局 \"文章名\" #发布文章的操作，文章开始没有被分类到post$ hexo server # 运行本地服务$ hexo generate # 自动根据当前目录下文件,生成静态网页$ hexo deploy # 远程部署，同步到 GitHub$ hexo clean # 清除静态页面缓存（清除 public 文件夹） 页面信息1234567title: \"XXX\" # 博文题目date: 2014-11-21 11:25:38 # 生成时间tags: tag # 标签, 多个标签也可以使用格式 [tag1, tag2, tag3,...]categories: cat # 多级使用 [cat1,cat2,cat3]comments: false # 关闭评论---正文, 使用 Markdown 语法书写 如果不想博文在首页全部显示, 并能出现阅读全文按钮效果, 需要在你想在首页显示的部分下添加123此处及以上的内容会在首页显示&lt;!--more--&gt;一下是在首页隐藏的部分 更换主题hexo 会有一个默认的主题，如果你不喜欢，快去重新挑一个你爱的吧，传送门。 我最后挑选了 hueman ，所以下面以 hueman 为例,介绍一下如何更换主题。首先当然是下载主题文件，下载之后需要更改文件夹名为 hueman (可以改成任何你喜欢的名字)，放在 themes 文件夹内，这时需要修改全局配置文件 _config.yml 里：1theme: hueman # 改为你的主题文件名 为了支持 hueman 内置的 search 功能需要下载 hexo-generator-json-content 1$ npm install -S hexo-generator-json-content 详细见文档 每个主题的目录下都有一个主题配置文件 _config.yml ,在这里修改所有主题相关的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# Menusmenu: Home: / # Home的路径，默认是 / # Delete this row if you don't want categories in your header nav bar Categories: # 加上这个参数，会在 menu 菜单里显示文章分类的列表 Tags: # 加上这个参数，会在 menu 菜单里显示文章标签的列表 About: /2018/01/16/hexo # 同理 如果加上一个 About ，menu 菜单会显示About按钮，如果后面配置的是一个路径，菜单会直接跳转到这个路径下#如果需要副标题 需要添加subtitle: # 副标题# Customizecustomize: logo: # 配置你自己的logo width: 158 # 你要设置的图片宽高 px height: 38 url: images/logo-name3.png # 图片放在 hueman/source/css/images 内 theme_color: '#ff7849' # 可自定义的主题色 highlight: androidstudio sidebar: left # sidebar position, options: left, right thumbnail: true # 是否开启文章缩略图 favicon: # path to favicon social_links: # for more icons, please see http://fontawesome.io/icons/#brand #twitter: / #facebook: / #google-plus: / github: https://github.com/isZoe #weibo: / #rss: /# Widgetswidgets: - recent_posts - category - archive - tag - tagcloud - links# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false# Commentcomment: disqus: #hexo-theme-hueman # enter disqus shortname here duoshuo: # enter duoshuo shortname here youyan: # enter youyan uid here facebook: # enter true to enable isso: # enter the domain name of your own comment isso server eg. comments.example.com changyan: appId: # enter the changyan appId here appKey: # enter the changyan appKey here on: # enter true to enable valine: # Valine Comment System https://github.com/xCss/Valine on: # enter true to enable valine appId: # enter the leancloud application appId here appKey: # enter the leancloud application appKey here notify: # enter true to enable &lt;Mail notifier&gt; verify: # enter true to enable &lt;Validation code&gt; placeholder: Just Do It # enter the comment box placeholder# Shareshare: default # options: jiathis, bdshare, addtoany, default# Pluginsplugins: lightgallery: true # options: true, false justifiedgallery: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics baidu_analytics: # enter Baidu Analytics hash key bing_site_verification: # enter Bing verification key here mathjax: false # options: true, false# Miscellaneousmiscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links: #Hexo: http://hexo.io 此时你配置好了你的主题文件，大功告成，就可以爽爽的写博客了。 hueman 主题的一些小修改，和基础用法配置了主题文件之后，还是对它有一些小不满，于是做了一些细微的改动，还有一些文章配合主题的基本用法，也贴了出来。 文章多级分类想在侧边栏显示多级的文章分类，记得在 _config.yml 中开启Categories:。在文章.md头部加上1categories: [cat1 ,cat2] # 多级可使用数组的形式,侧边栏的分类 hueman 默认只支持到两级 如果想支持更多级分类，去 hueman/layout/widget/category.ejs1234567...&lt;%- list_categories(site.categories,&#123; depth: 2, // 把depth 参数修改成你想要的层级数 style: 'list', show_count: true,&#125;) %&gt;... 文章缩略图human 是支持文章缩略的一个主题，如果要使用文章缩略图，首选需要在主题配置 _config.yml 中开启thumbnail: true。默认会选取文章的第一张图作为缩略图，需要自定义的话，去文章.md在头部加上12thumbnail: 'css/images/hexo.jpg' # 图片放在 hueman/source/css/images 内 # 或者直接引用外链 如果把图片放在 hueman/source/css/images 内，直接写上面这个路径引用，http://localhost:4000/预览时会发现，在 page 的页面里面 sidebar 的预览图就会因为路径错误显示不正确。human 的文档里面使用了一个外链的图片，所以如果想图省事可以直接使用一个外链，但是如果想试用站内链接，我们需要对主题文件做一点小小的处理。我参考了一下 页面 logo 的处理方式，需要打开 hueman/layout/common/thumbnail.ejs1234567891011....&lt;% var thumbnailUrl = thumbnail(post) %&gt;&lt;% if (thumbnailUrl) &#123; %&gt; // -- &lt;span style=\"background-image:url(&lt;%- url_for(post.thumbnail) %&gt;)\" alt=\"&lt;%= post.title %&gt;\" class=\"thumbnail-image\"&gt;&lt;/span&gt; // 将 background-image:url(&lt;%- thumbnailUrl %&gt;) url的路径修改成以下参数 // add &lt;span style=\"background-image:url(&lt;%- url_for(post.thumbnail) %&gt;)\" alt=\"&lt;%= post.title %&gt;\" class=\"thumbnail-image\"&gt;&lt;/span&gt;&lt;% &#125; else &#123; %&gt; &lt;span class=\"thumbnail-image thumbnail-none\"&gt;&lt;/span&gt;&lt;% &#125; %&gt;.... 这样就可以把图片保存在本地啦～ 在文章中插入图片提供两种插入图片的方法 我们可以在全局配置文件 _config.yml1post_asset_folder: true 这样我们每次new,一个文章的时候,就会同时生成一个同名的文件夹，可以在里面放入图片，随后在文章中引用1&#123;% img XXX.jpg tit图片标题 替换文字 %&#125; 因为自己在文章中插入的图片不多，所以直接在 source 里面新建了一个文件夹 img ，把需要引用的图片放在了img/内，随后在文章中以绝对路径引用1&#123;% img /img/XXX.jpg tit图片标题 替换文字 %&#125; 添加 favicon在主题配置文件 _config.yml 中添加你的ico1favicon: /xrz.ico 注意将 .ico 文件放在主题文件夹的 source/ 目录下 source/xrz.ico 。 更换代码块样式这个只需要在主题配置文件 _config.yml 中修改 highlight 的值 1highlight: github # 更换你想要的代码主题样式 可以选择哪些样式呢，我们可以去 hueman/source/css/_highlight 文件夹,里面有很多 .styl 文件，文件名就是可选值。 简单的整理了一下自己的笔记，持续更新中.. 参考链接Hexo安装和配置","categories":[{"name":"Tool","slug":"Tool","permalink":"http://iszoe.github.io/categories/Tool/"}],"tags":[]},{"title":"Markdown 语法🐤","slug":"markdown","date":"2018-01-16T09:57:51.000Z","updated":"2018-02-23T17:20:19.584Z","comments":true,"path":"2018/01/16/markdown/","link":"","permalink":"http://iszoe.github.io/2018/01/16/markdown/","excerpt":"","text":"上标aaa1上标&lt;sup&gt;aaa&lt;/sup&gt; 标记区块引用 类似 email 中用的引用方式 1&gt; 类似 email 中用的引用方式 行间代码code1行间代码`code` 文字加粗文字加粗文字加粗对比文字加粗文字加粗 12345**文字加粗**__文字加粗__对比*文字加粗*_文字加粗_ 空一行123aaaa&amp;nbsp;aaaa","categories":[{"name":"Tool","slug":"Tool","permalink":"http://iszoe.github.io/categories/Tool/"}],"tags":[]}]}